// ============================================================================
// CONFIGURATION
// ============================================================================

generator client {
  provider = "prisma-client"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// AUTH & USERS
// ============================================================================

enum Role {
  USER
  ADMIN
}

// === STATUT DE COMPTE (RGPD) ===
enum AccountStatus {
  ACTIVE
  INACTIVE
  PENDING_DELETION
  ANONYMIZED
}

model User {
  id               String    @id @default(cuid())
  role             Role      @default(USER)
  name             String?   @db.VarChar(100)
  email            String    @unique @db.VarChar(255)
  emailVerified    Boolean   @default(false)
  image            String?   @db.VarChar(2048)
  stripeCustomerId String?   @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  deletedAt        DateTime?
  suspendedAt      DateTime? // Date de suspension du compte

  // === STATUT DE COMPTE (RGPD) ===
  accountStatus AccountStatus @default(ACTIVE)

  // === ANONYMISATION RGPD ===
  anonymizedAt        DateTime? // Date d'anonymisation effective
  deletionRequestedAt DateTime? // Demande de suppression enregistree

  sessions                  Session[]
  accounts                  Account[]
  orders                    Order[]
  cart                      Cart?
  addresses                 Address[]
  wishlist                  Wishlist?
  discountUsages            DiscountUsage[]
  newsletterSubscription    NewsletterSubscriber?

  // Relations avec les remboursements (audit)
  refundsCreated Refund[] @relation("RefundCreator")

  // Avis produits
  reviews ProductReview[]

  // Demandes de personnalisation
  customizationRequests CustomizationRequest[]

  @@index([accountStatus, deletionRequestedAt]) // process-account-deletions cron
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @db.VarChar(500)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String? @db.VarChar(45)
  userAgent String? @db.VarChar(500)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId, expiresAt]) // Couvre aussi userId seul
  @@index([expiresAt]) // cleanup-sessions cron: WHERE expiresAt < now()
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.VarChar(500)
  refreshToken          String?   @db.VarChar(500)
  idToken               String?   @db.VarChar(500)
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?   @db.VarChar(255)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@index([providerId, accountId])
  @@index([accessTokenExpiresAt]) // cleanup-sessions cron: expired OAuth tokens
  @@index([refreshTokenExpiresAt]) // cleanup-sessions cron: expired refresh tokens
}

model Verification {
  id         String   @id
  identifier String
  value      String   @db.VarChar(500)
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@index([expiresAt]) // cleanup-sessions cron: WHERE expiresAt < now()
}

model Address {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  firstName  String  @db.VarChar(50)
  lastName   String  @db.VarChar(50)
  address1   String  @db.VarChar(255)
  address2   String? @db.VarChar(255)
  postalCode String  @db.VarChar(10)
  city       String  @db.VarChar(100)
  country    String  @default("FR") @db.VarChar(2)
  phone      String  @db.VarChar(20)

  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Note: Contrainte unique partielle ajoutee via migration SQL brute
  // pour garantir qu'un seul enregistrement a isDefault: true par userId

  @@index([userId, isDefault]) // Couvre aussi userId seul
}

// ============================================================================
// CATALOGUE - ENUMS
// ============================================================================

enum ProductStatus {
  DRAFT
  PUBLIC
  ARCHIVED
}

enum CollectionStatus {
  DRAFT
  PUBLIC
  ARCHIVED
}

enum MediaType {
  IMAGE
  VIDEO
}

/// Statut de moderation des avis produits
enum ReviewStatus {
  PUBLISHED // Auto-publie (defaut)
  HIDDEN    // Masque par moderation (spam, inapproprie, etc.)
}

// ============================================================================
// CATALOGUE - ENUMS ADDITIONNELS
// ============================================================================

/// Source d'une action sur une commande (audit trail)
enum HistorySource {
  ADMIN
  WEBHOOK
  SYSTEM
  CUSTOMER
}

// ============================================================================
// CATALOGUE - REFERENTIELS
// ============================================================================

model ProductType {
  id          String  @id @default(cuid())
  slug        String  @unique
  label       String  @unique @db.VarChar(50)
  description String? @db.Text
  isActive    Boolean @default(true)
  isSystem    Boolean @default(false) // Types systeme non modifiables/supprimables

  products              Product[]
  customizationRequests CustomizationRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

}

model Color {
  id        String       @id @default(cuid())
  slug      String       @unique
  name      String       @unique @db.VarChar(100)
  hex       String       @db.VarChar(7)
  isActive  Boolean      @default(true) // Coherence avec Material
  skus      ProductSku[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

}

model Material {
  id          String       @id @default(cuid())
  slug        String       @unique
  name        String       @unique @db.VarChar(100)
  description String?      @db.Text
  isActive    Boolean      @default(true)
  skus        ProductSku[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

}

// ============================================================================
// CATALOGUE - COLLECTIONS
// ============================================================================

model Collection {
  id          String           @id @default(cuid())
  name        String           @db.VarChar(100)
  slug        String           @unique
  description String?          @db.Text
  status      CollectionStatus @default(DRAFT)

  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt
  products  ProductCollection[]

}

/// Table de jointure explicite Product <-> Collection (many-to-many)
/// Permet a un produit d'appartenir a plusieurs collections
model ProductCollection {
  id           String     @id @default(cuid())
  productId    String
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  collectionId String
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  /// Date d'ajout a la collection (pour tri automatique par nouveautes)
  addedAt DateTime @default(now())

  /// Produit mis en avant dans la collection (pour hero/banner)
  /// Un seul produit peut etre featured par collection (gere cote applicatif)
  isFeatured Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Un produit ne peut appartenir qu'une seule fois a une collection
  @@unique([productId, collectionId])
  @@index([collectionId]) // FK reverse lookup
}

// ============================================================================
// CATALOGUE - PRODUITS & SKUs
// ============================================================================

model Product {
  id          String        @id @default(cuid())
  slug        String        @unique
  title       String        @db.VarChar(200)
  description String?       @db.Text
  status      ProductStatus @default(PUBLIC)

  type   ProductType? @relation(fields: [typeId], references: [id], onDelete: SetNull)
  typeId String?

  collections ProductCollection[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete pour preserver historique commandes

  skus       ProductSku[]
  orderItems OrderItem[]

  customizationInspirations CustomizationRequest[] @relation("CustomizationInspirations")

  // Avis produits
  reviews     ProductReview[]
  reviewStats ProductReviewStats?

  // Wishlist
  wishlistItems WishlistItem[]

  @@index([typeId])
}

model ProductSku {
  id        String  @id @default(cuid())
  sku       String  @unique @db.VarChar(100)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  colorId  String?
  color    Color?  @relation(fields: [colorId], references: [id], onDelete: SetNull)

  materialId String?
  material   Material? @relation(fields: [materialId], references: [id], onDelete: SetNull)

  size String? @db.VarChar(50)

  // Prix en regime micro-entreprise (exonere de TVA - art. 293 B du CGI)
  // Le nom "priceInclTax" est conserve pour compatibilite, mais il s'agit du prix FINAL sans TVA
  // Exemple : 30 euros = 3000 centimes (prix que paie le client, sans TVA ajoutee)
  priceInclTax   Int
  compareAtPrice Int? // Prix avant reduction (optionnel, pour afficher prix barre)
  inventory      Int     @default(0)
  isActive       Boolean @default(true)

  isDefault Boolean @default(false)

  images                    SkuMedia[]
  orderItems                OrderItem[]
  cartItems                 CartItem[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete pour preserver historique commandes

  // Garantir unicite des combinaisons produit/couleur/taille/materiau
  // Evite les doublons de variantes (ex: 2 SKUs "Bague Rouge Taille 52 Argent")
  @@unique([productId, colorId, size, materialId])
  @@index([colorId])
  @@index([materialId])
}

model SkuMedia {
  id    String     @id @default(cuid())
  skuId String
  sku   ProductSku @relation(fields: [skuId], references: [id], onDelete: Cascade)

  url          String  @db.VarChar(2048)
  thumbnailUrl String? @db.VarChar(2048) // Thumbnail pour videos (poster)
  blurDataUrl  String? @db.Text          // Base64 blur placeholder (~200 bytes)
  altText      String?   @db.VarChar(255)
  mediaType    MediaType @default(IMAGE)
  isPrimary    Boolean   @default(false)
  position     Int       @default(0) // Position pour ordre d'affichage

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([skuId, position])
}

// ============================================================================
// PANIER
// ============================================================================

model Cart {
  id String @id @default(cuid())

  userId    String? @unique
  user      User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessionId String? @unique

  expiresAt DateTime?

  items CartItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([expiresAt])
}

model CartItem {
  id     String @id @default(cuid())
  cartId String
  cart   Cart   @relation(fields: [cartId], references: [id], onDelete: Cascade)

  skuId String
  sku   ProductSku @relation(fields: [skuId], references: [id], onDelete: Restrict)

  quantity Int @default(1)

  // Prix snapshot au moment de l'ajout au panier (en centimes)
  // Protege contre les changements de prix entre l'ajout et le paiement
  // Exemple: 29,99 euros = 2999 centimes
  priceAtAdd Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cartId, skuId])
  @@index([skuId])
}

// ============================================================================
// WISHLIST (FAVORIS)
// ============================================================================

model Wishlist {
  id String @id @default(cuid())

  // Support utilisateur connecte OU session invite
  userId    String? @unique
  user      User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessionId String? @unique // UUID pour sessions invite (cookie httpOnly)

  // Date d'expiration pour les wishlists invite (null = utilisateur connecte)
  expiresAt DateTime?

  items WishlistItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([expiresAt]) // Pour le nettoyage des wishlists expirees
}

model WishlistItem {
  id         String   @id @default(cuid())
  wishlistId String
  wishlist   Wishlist @relation(fields: [wishlistId], references: [id], onDelete: Cascade)

  // SetNull permet l'archivage produit sans bloquer les wishlists existantes
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Un produit ne peut etre ajoute qu'une seule fois par wishlist
  // Note: Contrainte unique sur champ nullable - validation metier cote applicatif
  @@unique([wishlistId, productId])
  @@index([productId])
}

// ============================================================================
// COMMANDES - ENUMS
// ============================================================================

enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  EXPIRED // Checkout session expired (no payment attempted)
  PARTIALLY_REFUNDED
  REFUNDED
}

enum FulfillmentStatus {
  UNFULFILLED
  PROCESSING
  SHIPPED
  DELIVERED
  RETURNED
}

/// Actions tracables sur les commandes (audit trail)
/// Requis pour conformite legale (Art. L123-22 Code de Commerce)
enum OrderAction {
  CREATED            // Creation de la commande
  PAID               // Paiement recu
  PROCESSING         // Mise en preparation
  SHIPPED            // Expedition
  DELIVERED          // Livraison confirmee
  CANCELLED          // Annulation
  RETURNED           // Retour client
  STATUS_REVERTED    // Retour a un statut precedent
  TRACKING_UPDATED   // Mise a jour du suivi
  ADDRESS_UPDATED    // Mise a jour de l'adresse de livraison
  INVOICE_GENERATED  // Facture generee
}

/// Statut de la facture associée à une commande
enum InvoiceStatus {
  PENDING   // Facture en attente de génération
  GENERATED // Facture générée (PDF disponible)
  VOIDED    // Facture annulée (commande annulée après facturation)
}

// ============================================================================
// COMMANDES - MODELS
// ============================================================================

model Order {
  id          String  @id @default(cuid())
  orderNumber String  @unique @db.VarChar(50)
  userId      String?
  user        User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // === IDENTIFIANTS STRIPE (CRITIQUES) ===
  stripeCheckoutSessionId String? @unique // cs_xxx
  stripePaymentIntentId   String? @unique // pi_xxx
  stripeCustomerId        String? @db.VarChar(50) // cus_xxx
  stripeInvoiceId         String? @unique // in_xxx

  // === INFORMATIONS CLIENT ===
  customerEmail String @db.VarChar(255)
  customerName  String @db.VarChar(100)
  customerPhone String? @db.VarChar(20)

  // === ADRESSE DE LIVRAISON (DENORMALISEE - SNAPSHOT) ===
  shippingFirstName  String  @db.VarChar(50)
  shippingLastName   String  @db.VarChar(50)
  shippingAddress1   String  @db.VarChar(255)
  shippingAddress2   String? @db.VarChar(255)
  shippingPostalCode String  @db.VarChar(10)
  shippingCity       String  @db.VarChar(100)
  shippingCountry    String  @default("FR") @db.VarChar(2)
  shippingPhone      String  @db.VarChar(20)

  // === MONTANTS (EN CENTIMES) ===
  subtotal       Int
  discountAmount Int          @default(0) // Montant total des reductions appliquees
  taxAmount      Int          @default(0) // Micro-entreprise : Toujours 0 (exoneree de TVA - art. 293 B du CGI)
  shippingCost   Int          @default(0) // Frais de livraison
  total          Int // Formule: MAX(0, subtotal - discountAmount + shippingCost)
  currency       String       @default("EUR") @db.VarChar(3)

  // === ECHECS DE PAIEMENT ===
  // Stocke les codes d'erreur du dernier echec (historique complet dans WebhookEvent)
  paymentFailureCode    String? @db.VarChar(100) // Code Stripe: "card_declined", "expired_card", etc.
  paymentDeclineCode    String? @db.VarChar(100) // Code reseau detaille (Visa/MC)
  paymentFailureMessage String? @db.VarChar(500) // Message lisible pour debug

  // === FACTURATION (Conformité Article 286 CGI) ===
  invoiceNumber      String?        @unique @db.VarChar(30) // Format: F-YYYY-NNNNN (séquentiel par année)
  invoiceStatus      InvoiceStatus? // null = pas encore de facture
  invoiceGeneratedAt DateTime?      // Date de première génération de la facture

  // === LIVRAISON ===
  shippingMethod    String?          @db.VarChar(20) // Type de livraison
  shippingCarrier   String?          @db.VarChar(30) // Transporteur (valeurs: colissimo, chronopost, mondial_relay, dpd, lettre_suivie, autre)
  shippingRateId    String? // ID du tarif Stripe utilise
  trackingNumber    String? @db.VarChar(50)
  trackingUrl       String? @db.VarChar(2048) // URL de suivi
  estimatedDelivery DateTime? // Date estimee de livraison
  actualDelivery    DateTime? // Date reelle de livraison
  shippedAt         DateTime? // Date d'expedition

  // === EMAIL INCITATIF AVIS ===
  reviewRequestSentAt DateTime? // Date d'envoi de l'email de demande d'avis

  // === STATUTS ===
  status            OrderStatus       @default(PENDING)
  paymentStatus     PaymentStatus     @default(PENDING)
  fulfillmentStatus FulfillmentStatus @default(UNFULFILLED)

  // === PAIEMENT ===
  paymentMethod String        @default("CARD") @db.VarChar(20)
  paidAt        DateTime?

  // === RELATIONS ===
  items          OrderItem[]
  discountUsages DiscountUsage[]
  refunds        Refund[]
  notes          OrderNote[]
  history        OrderHistory[] // Audit trail (conformite legale)
  disputes       Dispute[]

  // === SOFT DELETE (Conformite legale - Conservation 10 ans) ===
  // Ne JAMAIS supprimer physiquement une commande (Art. L123-22 Code de Commerce)
  deletedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, createdAt(sort: Desc)])
  @@index([customerEmail])
  @@index([stripeCustomerId])
  @@index([paymentStatus, createdAt]) // sync-async-payments cron
  @@index([fulfillmentStatus, actualDelivery]) // review-request-emails cron
}

/// Historique des actions sur les commandes (audit trail)
/// Obligatoire pour conformite legale francaise (Art. L123-22 Code de Commerce)
/// Conservation 10 ans avec la commande
/// onDelete: SetNull pour preserver l'audit trail meme si commande supprimee
model OrderHistory {
  id      String  @id @default(cuid())
  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id], onDelete: SetNull)

  /// Action effectuee sur la commande
  action OrderAction

  /// Statuts avant/apres pour les changements de statut
  previousStatus            OrderStatus?
  newStatus                 OrderStatus?
  previousPaymentStatus     PaymentStatus?
  newPaymentStatus          PaymentStatus?
  previousFulfillmentStatus FulfillmentStatus?
  newFulfillmentStatus      FulfillmentStatus?

  /// Note explicative (ex: raison annulation, commentaire admin)
  note String? @db.Text

  /// Metadonnees supplementaires (JSON flexible pour donnees additionnelles)
  metadata Json?

  /// Auteur de l'action
  authorId   String? // ID de l'admin ou null pour actions systeme
  authorName String? @db.VarChar(100) // Denormalise pour audit (si admin supprime plus tard)

  /// Source de l'action
  source HistorySource @default(ADMIN)

  /// Timestamp de l'action
  createdAt DateTime @default(now())

  // === INDEXES ===
  @@index([orderId, createdAt(sort: Desc)])
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // onDelete: SetNull - Preserve l'historique des ventes, le snapshot (productTitle, etc.) reste
  // Un produit soft-deleted rend productId null sans bloquer ni cascader
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  // onDelete: Restrict intentionnel - Un SKU avec commandes ne peut pas etre supprime
  // Garantit l'integrite comptable (Art. L123-22 Code de commerce - conservation 10 ans)
  // Pour "supprimer" un SKU : utiliser le soft-delete sur Product ou archiver le SKU
  skuId String
  sku   ProductSku @relation(fields: [skuId], references: [id], onDelete: Restrict)

  // Snapshot des donnees produit au moment de la commande
  productTitle       String  @db.VarChar(200)
  productDescription String? @db.Text
  productImageUrl    String? @db.VarChar(2048)

  skuSku      String? @db.VarChar(100) // Snapshot du code SKU au moment de la commande
  skuColor    String? @db.VarChar(100)
  skuMaterial String? @db.VarChar(100)
  skuSize     String? @db.VarChar(50)
  skuImageUrl String? @db.VarChar(2048)

  // Prix et quantite
  price    Int // Prix unitaire FINAL sans TVA en centimes (micro-entreprise exoneree)
  quantity Int

  // Relations
  refundItems RefundItem[]

  // Avis produit (un OrderItem peut avoir un avis, relation 1:1)
  review ProductReview?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([skuId])
}

/// Notes internes sur les commandes (visibles uniquement par les admins)
/// Permet de documenter les echanges clients, incidents, ou actions speciales
model OrderNote {
  id String @id @default(cuid())

  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id], onDelete: SetNull)

  // Contenu de la note
  content String @db.Text

  // Admin qui a cree la note
  authorId   String
  authorName String @db.VarChar(100) // Denormalise pour historique si admin supprime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime? // Soft delete pour audit trail

  @@index([orderId, createdAt(sort: Desc)])
}

// ============================================================================
// REMBOURSEMENTS
// ============================================================================

enum RefundReason {
  CUSTOMER_REQUEST // Droit de retractation (14 jours)
  DEFECTIVE        // Bijou casse / abime
  WRONG_ITEM       // Erreur de preparation de commande
  LOST_IN_TRANSIT  // Colis perdu par le transporteur
  FRAUD            // Fraude averee
  OTHER            // Autre
}

enum RefundStatus {
  PENDING   // Demande recue / En attente de validation
  APPROVED  // Valide, en attente de traitement Stripe
  COMPLETED // Rembourse effectivement (Stripe a confirme)
  REJECTED  // Refuse (ex: retour hors delai)
  FAILED    // Echec technique Stripe
  CANCELLED // Annule par l'admin (soft delete)
}

model Refund {
  id String @id @default(cuid())

  // Relation avec la commande (Restrict pour protection comptable)
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Restrict)

  // Identifiant Stripe du remboursement (pour lier la compta)
  stripeRefundId String? @unique // re_xxxx

  // Montants
  amount   Int          // Montant TOTAL rembourse en centimes
  currency String       @default("EUR") @db.VarChar(3)

  // Raison et Statut
  reason        RefundReason
  status        RefundStatus @default(PENDING)
  failureReason String?      // Detail si FAILED (ex: "insufficient_funds", "charge_already_refunded")

  // Note interne (ex: "Le fermoir etait casse, photos recues par mail")
  note String? @db.Text

  // Details des articles rembourses
  items RefundItem[]

  // Audit
  createdBy     String? // ID de l'admin qui a cree le remboursement
  createdByUser User?   @relation("RefundCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  processedAt   DateTime? // Date de traitement effectif (Stripe)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // === SOFT DELETE (Conformite legale - Conservation 10 ans) ===
  // Ne JAMAIS supprimer physiquement un remboursement (Art. L123-22 Code de Commerce)
  deletedAt DateTime?

  @@index([orderId])
  @@index([status, processedAt]) // reconcile-refunds cron
}

model RefundItem {
  id String @id @default(cuid())

  refundId String?
  refund   Refund? @relation(fields: [refundId], references: [id], onDelete: SetNull)

  // Lien precis vers la ligne de commande d'origine
  // Cela permet de savoir quel produit exact (et a quel prix d'origine) est rembourse
  orderItemId String
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Restrict)

  quantity Int // Nombre d'unites remboursees (ex: 1 sur 2 achetees)

  amount Int // Montant rembourse pour CET article (en centimes)
  // Permet de rembourser moins que le prix d'achat si decote appliquee

  // Gestion de stock
  restock Boolean @default(true) // Faut-il remettre le produit en stock (inventory +1) ?
  // false si le produit est abime/casse

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([refundId])
  @@index([orderItemId])
}

// ============================================================================
// LITIGES STRIPE (CHARGEBACKS)
// ============================================================================

enum DisputeStatus {
  NEEDS_RESPONSE     // Requires evidence submission
  UNDER_REVIEW       // Evidence submitted, Stripe reviewing
  WON                // Resolved in merchant's favor
  LOST               // Resolved in customer's favor
  CHARGE_REFUNDED    // Charge was refunded before dispute resolved
}

enum DisputeReason {
  DUPLICATE
  FRAUDULENT
  SUBSCRIPTION_CANCELED
  PRODUCT_UNACCEPTABLE
  PRODUCT_NOT_RECEIVED
  UNRECOGNIZED
  CREDIT_NOT_PROCESSED
  GENERAL
}

/// Litige Stripe (chargeback) associe a une commande
/// Permet de tracker les disputes de maniere structuree au lieu de notes texte libres
model Dispute {
  id              String        @id @default(cuid())
  stripeDisputeId String        @unique // dp_xxx

  // Relation avec la commande (Restrict pour protection comptable)
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Restrict)

  // Montants
  amount   Int    // Montant conteste en centimes
  fee      Int    @default(0) // Frais de litige Stripe (~1500 = 15 EUR)
  currency String @default("EUR") @db.VarChar(3)

  // Raison et statut
  reason DisputeReason
  status DisputeStatus @default(NEEDS_RESPONSE)

  // Deadline Stripe pour soumettre les preuves
  dueBy DateTime?

  // Resolution
  resolvedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([status, dueBy]) // Dashboard: disputes needing attention
}

// ============================================================================
// CODES PROMO & REDUCTIONS
// ============================================================================

enum DiscountType {
  PERCENTAGE   // Ex: -20%
  FIXED_AMOUNT // Ex: -10 euros
}

model Discount {
  id   String @id @default(cuid())
  code String @unique @db.VarChar(30) // Ex: "BIENVENUE10", "ETE2025"

  // Type et valeur de la reduction
  type  DiscountType
  value Int // En pourcentage (20 = 20%) ou centimes (1000 = 10 euros)

  // Conditions d'utilisation
  minOrderAmount  Int? // Montant minimum de commande en centimes (ex: 5000 = 50 euros)
  maxUsageCount   Int? // Nombre max d'utilisations total (null = illimite)
  maxUsagePerUser Int? // Nombre max d'utilisations par utilisateur (null = illimite)

  // Periode de validite
  startsAt DateTime  @default(now())
  endsAt   DateTime?

  // Statistiques
  usageCount Int @default(0) // Compteur d'utilisations

  // Etat
  isActive Boolean @default(true)

  // Relations
  usages DiscountUsage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

}

model DiscountUsage {
  id         String   @id @default(cuid())
  discountId String
  discount   Discount @relation(fields: [discountId], references: [id], onDelete: Restrict)

  // Utilisateur (optionnel pour guest checkout)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Commande associee (Restrict pour protection comptable)
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Restrict)

  // Snapshot du code promo utilise (le code peut etre modifie apres usage)
  discountCode String @db.VarChar(30)

  // Montant de la reduction appliquee (snapshot)
  amountApplied Int // En centimes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([discountId, orderId])
  @@index([orderId])
  @@index([discountId, userId]) // Pour verifier usage par utilisateur, couvre aussi discountId seul
}

// ============================================================================
// NEWSLETTER
// ============================================================================

enum NewsletterStatus {
  PENDING      // En attente de confirmation (double opt-in)
  CONFIRMED    // Email confirme, abonnement actif
  UNSUBSCRIBED // Desabonne
}

model NewsletterSubscriber {
  id               String  @id @default(cuid())
  email            String  @unique @db.VarChar(255)
  unsubscribeToken String  @unique

  // === STATUT NEWSLETTER ===
  status NewsletterStatus @default(PENDING)

  // Lien optionnel avec un compte utilisateur
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Double opt-in : Confirmation email obligatoire
  confirmationToken  String?   @unique // Token unique pour confirmer l'inscription
  confirmationSentAt DateTime? // Date d'envoi de l'email de confirmation
  confirmedAt        DateTime? // Date de confirmation par l'utilisateur

  // Champs de tracabilite RGPD
  ipAddress             String? @db.VarChar(45) // IP inscription
  confirmationIpAddress String? @db.VarChar(45) // IP confirmation (preuve RGPD)
  userAgent             String? @db.VarChar(500)
  consentSource         String? @default("newsletter_form")
  consentTimestamp      DateTime @default(now())

  subscribedAt   DateTime  @default(now())
  unsubscribedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime? // Soft delete pour RGPD

}

// ============================================================================
// AVIS PRODUITS
// ============================================================================

/// Avis produit laisse par un acheteur verifie
/// Un seul avis par utilisateur et par produit (pas par OrderItem)
/// Permet de mettre a jour l'avis apres un nouvel achat
model ProductReview {
  id String @id @default(cuid())

  // === RELATIONS PRINCIPALES ===
  // Produit concerne (relation vers Product, pas ProductSku)
  // Les avis sont au niveau produit, pas variante
  // SetNull permet l'archivage produit sans bloquer (avis conserve, productId devient null)
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  // Auteur de l'avis (acheteur verifie)
  // SetNull pour conformite RGPD (anonymisation utilisateur possible)
  userId String?
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Preuve d'achat : OrderItem du PREMIER achat ayant permis de laisser l'avis
  // Ce champ ne change pas lors des mises a jour de l'avis (meme si rachat ulterieur)
  // Garantit que seuls les acheteurs verifies peuvent laisser un avis
  orderItemId String    @unique // Un OrderItem ne peut generer qu'un seul avis
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Restrict)

  // === CONTENU DE L'AVIS ===
  rating  Int     // Note de 1 a 5 etoiles (CHECK constraint DB + validation Zod cote serveur)
  title   String? @db.VarChar(150) // Titre optionnel de l'avis
  content String  @db.Text // Commentaire texte

  // === MODERATION ===
  status ReviewStatus @default(PUBLISHED) // Auto-publie, moderation a posteriori

  // === RELATIONS ===
  medias   ReviewMedia[] // Photos de l'avis (max 3)
  response ReviewResponse? // Reponse admin (unique)

  // === TIMESTAMPS ===
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete RGPD (10 ans conservation)

  // === CONTRAINTES ===
  // Un utilisateur ne peut laisser qu'un seul avis par produit
  // S'il rachete le produit, il peut modifier son avis existant
  // Note: Contrainte unique sur champs nullable - PostgreSQL permet plusieurs (NULL, NULL)
  // La validation metier est faite cote applicatif pour les avis actifs
  @@unique([userId, productId])

  @@index([productId])
}

/// Photo jointe a un avis produit
/// Maximum 3 photos par avis (validation applicative)
model ReviewMedia {
  id       String        @id @default(cuid())
  reviewId String
  review   ProductReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  // === MEDIA (Pattern SkuMedia) ===
  url         String  @db.VarChar(2048) // URL UploadThing
  blurDataUrl String? @db.Text // Base64 blur placeholder (~200 bytes)
  altText     String? @db.VarChar(255) // Alt text pour accessibilite

  // Position pour ordre d'affichage (0, 1, 2)
  position Int @default(0)

  // === TIMESTAMPS ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // === INDEXES ===
  @@index([reviewId, position])
}

/// Reponse de l'admin/marque a un avis
/// Une seule reponse possible par avis
model ReviewResponse {
  id       String        @id @default(cuid())
  reviewId String        @unique // Une seule reponse par avis
  review   ProductReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  // === CONTENU ===
  content String @db.Text // Reponse texte de la marque

  // === AUTEUR ADMIN (Pattern OrderNote) ===
  // L'admin qui a redige la reponse
  authorId   String // ID de l'admin
  authorName String @db.VarChar(100) // Denormalise pour historique si admin supprime

  // === TIMESTAMPS ===
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete RGPD

}

/// Statistiques agregees des avis par produit
/// Table de cache pour performances (evite COUNT/AVG a chaque requete)
/// Mise a jour via trigger applicatif apres creation/modification/suppression d'avis
model ProductReviewStats {
  id        String  @id @default(cuid())
  productId String  @unique
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // === STATISTIQUES AGREGEES ===
  totalCount    Int     @default(0) // Nombre total d'avis publies
  averageRating Decimal @default(0) @db.Decimal(3, 2) // Moyenne (ex: 4.75)

  // Distribution des notes (pour graphique cliquable)
  rating1Count Int @default(0) // Nombre d'avis 1 etoile
  rating2Count Int @default(0) // Nombre d'avis 2 etoiles
  rating3Count Int @default(0) // Nombre d'avis 3 etoiles
  rating4Count Int @default(0) // Nombre d'avis 4 etoiles
  rating5Count Int @default(0) // Nombre d'avis 5 etoiles

  // === TIMESTAMPS ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

}

// ============================================================================
// WEBHOOKS IDEMPOTENCY (Stripe)
// ============================================================================

enum WebhookEventStatus {
  PENDING    // Recu, en attente de traitement
  PROCESSING // En cours de traitement
  COMPLETED  // Traite avec succes
  FAILED     // Echec du traitement
  SKIPPED    // Ignore (type non gere ou doublon)
}

/// Evenements webhook Stripe
/// Permet l'idempotence et l'audit trail des webhooks
model WebhookEvent {
  id            String             @id @default(cuid())
  stripeEventId String             @unique // evt_xxx - Cle d'idempotence
  eventType     String             @db.VarChar(100) // checkout.session.completed, etc.
  status        WebhookEventStatus @default(PENDING)
  errorMessage  String?            @db.Text
  attempts      Int                @default(0)
  receivedAt    DateTime           @default(now())
  processedAt   DateTime?

  @@index([processedAt]) // cleanup-webhook-events cron
  @@index([status, processedAt]) // cleanup + retry queries filter by status then processedAt
  @@index([status, receivedAt]) // cleanup SKIPPED/stale webhook events by receivedAt
}

// ============================================================================
// EMAILS ECHOUES (retry automatique via cron)
// ============================================================================

enum FailedEmailStatus {
  PENDING   // En attente de retry
  RETRIED   // Retry effectue avec succes
  EXHAUSTED // Nombre max de tentatives atteint
}

/// Emails transactionnels echoues, retentes automatiquement par le cron retry-failed-emails
/// Retention : 30 jours (nettoye par cleanup cron)
model FailedEmail {
  id        String            @id @default(cuid())
  to        String            @db.VarChar(255)
  subject   String            @db.VarChar(500)
  template  String            @db.VarChar(100) // e.g. "shipping-confirmation", "delivery-confirmation"
  payload   Json              // Serialized template props for re-rendering
  status    FailedEmailStatus @default(PENDING)
  attempts  Int               @default(0)
  lastError String?           @db.Text
  orderId   String?           // Optional reference for context

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
}

// ============================================================================
// DEMANDES DE PERSONNALISATION
// ============================================================================

enum CustomizationRequestStatus {
  PENDING     // Nouvelle demande
  IN_PROGRESS // En cours de traitement
  COMPLETED   // Realise
  CANCELLED   // Annule
}

/// Demande de personnalisation de bijou
/// Stocke les demandes clients pour creations sur mesure
model CustomizationRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime? // Soft delete (RGPD - Art. L123-22 Code de Commerce : 10 ans)

  // === UTILISATEUR CONNECTE (optionnel) ===
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // === INFORMATIONS CONTACT ===
  firstName String @db.VarChar(50)
  email     String @db.VarChar(255)
  phone     String? @db.VarChar(20)

  // === TYPE DE PRODUIT ===
  productTypeLabel String       @db.VarChar(100) // Label du type selectionne (snapshot)
  productType      ProductType? @relation(fields: [productTypeId], references: [id], onDelete: SetNull)
  productTypeId    String?

  // === INSPIRATIONS (produits existants comme reference) ===
  inspirationProducts Product[] @relation("CustomizationInspirations")

  // === DESCRIPTION ===
  details String @db.Text // Description detaillee de la demande

  // === STATUT ET SUIVI ===
  status      CustomizationRequestStatus @default(PENDING)
  adminNotes  String?                    @db.Text // Notes internes admin
  respondedAt DateTime?                          // Date de premiere reponse

  @@index([status, createdAt(sort: Desc)])
  @@index([email])
  @@index([createdAt(sort: Desc)])
  @@index([deletedAt, status])
  @@index([userId, status]) // Page "Mes demandes" : demandes par statut
}
